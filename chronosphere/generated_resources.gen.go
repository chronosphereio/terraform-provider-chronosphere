// Code generated by go generate; DO NOT EDIT.
package chronosphere

import (
	"context"

	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/apiclients"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable/client/consumption_config"
	configunstablemodels "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable/models"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/bucket"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/collection"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/dashboard"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/dataset"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/derived_label"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/derived_metric"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/drop_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/gcp_metrics_integration"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/grafana_dashboard"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/log_allocation_config"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/log_ingest_config"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/log_scale_action"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/log_scale_alert"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/mapping_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/monitor"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/notification_policy"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/notifier"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/otel_metrics_ingestion"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/recording_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/resource_pools"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/rollup_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/service_account"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/slo"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/team"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/trace_jaeger_remote_sampling_strategy"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/trace_metrics_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/trace_tail_sampling_rules"
	configv1models "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/models"
)

type generatedBucket struct{}

func (generatedBucket) slugOf(m *configv1models.Configv1Bucket) string {
	return m.Slug
}

func (generatedBucket) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Bucket,
	dryRun bool,
) (string, error) {
	req := &bucket.CreateBucketParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateBucketRequest{
			Bucket: m,
			DryRun: dryRun,
		},
	}
	resp, err := clients.ConfigV1.Bucket.CreateBucket(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Bucket
	if e == nil {
		return "", nil
	}
	return (generatedBucket{}).slugOf(e), nil
}

func (generatedBucket) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Bucket, error) {
	req := &bucket.ReadBucketParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Bucket.ReadBucket(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Bucket, nil
}

func (generatedBucket) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Bucket,
	params updateParams,
) error {
	req := &bucket.UpdateBucketParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateBucketBody{

			Bucket:          m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Bucket.UpdateBucket(req)
	return err
}
func (generatedBucket) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &bucket.DeleteBucketParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Bucket.DeleteBucket(req)
	return err
}

type generatedCollection struct{}

func (generatedCollection) slugOf(m *configv1models.Configv1Collection) string {
	return m.Slug
}

func (generatedCollection) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Collection,
	dryRun bool,
) (string, error) {
	req := &collection.CreateCollectionParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateCollectionRequest{
			Collection: m,
			DryRun:     dryRun,
		},
	}
	resp, err := clients.ConfigV1.Collection.CreateCollection(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Collection
	if e == nil {
		return "", nil
	}
	return (generatedCollection{}).slugOf(e), nil
}

func (generatedCollection) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Collection, error) {
	req := &collection.ReadCollectionParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Collection.ReadCollection(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Collection, nil
}

func (generatedCollection) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Collection,
	params updateParams,
) error {
	req := &collection.UpdateCollectionParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateCollectionBody{

			Collection:      m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Collection.UpdateCollection(req)
	return err
}
func (generatedCollection) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &collection.DeleteCollectionParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Collection.DeleteCollection(req)
	return err
}

type generatedDashboard struct{}

func (generatedDashboard) slugOf(m *configv1models.Configv1Dashboard) string {
	return m.Slug
}

func (generatedDashboard) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Dashboard,
	dryRun bool,
) (string, error) {
	req := &dashboard.CreateDashboardParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateDashboardRequest{
			Dashboard: m,
			DryRun:    dryRun,
		},
	}
	resp, err := clients.ConfigV1.Dashboard.CreateDashboard(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Dashboard
	if e == nil {
		return "", nil
	}
	return (generatedDashboard{}).slugOf(e), nil
}

func (generatedDashboard) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Dashboard, error) {
	req := &dashboard.ReadDashboardParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Dashboard.ReadDashboard(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Dashboard, nil
}

func (generatedDashboard) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Dashboard,
	params updateParams,
) error {
	req := &dashboard.UpdateDashboardParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateDashboardBody{

			Dashboard:       m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Dashboard.UpdateDashboard(req)
	return err
}
func (generatedDashboard) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &dashboard.DeleteDashboardParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Dashboard.DeleteDashboard(req)
	return err
}

type generatedDataset struct{}

func (generatedDataset) slugOf(m *configv1models.Configv1Dataset) string {
	return m.Slug
}

func (generatedDataset) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Dataset,
	dryRun bool,
) (string, error) {
	req := &dataset.CreateDatasetParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateDatasetRequest{
			Dataset: m,
			DryRun:  dryRun,
		},
	}
	resp, err := clients.ConfigV1.Dataset.CreateDataset(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Dataset
	if e == nil {
		return "", nil
	}
	return (generatedDataset{}).slugOf(e), nil
}

func (generatedDataset) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Dataset, error) {
	req := &dataset.ReadDatasetParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Dataset.ReadDataset(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Dataset, nil
}

func (generatedDataset) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Dataset,
	params updateParams,
) error {
	req := &dataset.UpdateDatasetParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateDatasetBody{

			Dataset:         m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Dataset.UpdateDataset(req)
	return err
}
func (generatedDataset) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &dataset.DeleteDatasetParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Dataset.DeleteDataset(req)
	return err
}

type generatedDerivedLabel struct{}

func (generatedDerivedLabel) slugOf(m *configv1models.Configv1DerivedLabel) string {
	return m.Slug
}

func (generatedDerivedLabel) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1DerivedLabel,
	dryRun bool,
) (string, error) {
	req := &derived_label.CreateDerivedLabelParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateDerivedLabelRequest{
			DerivedLabel: m,
			DryRun:       dryRun,
		},
	}
	resp, err := clients.ConfigV1.DerivedLabel.CreateDerivedLabel(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.DerivedLabel
	if e == nil {
		return "", nil
	}
	return (generatedDerivedLabel{}).slugOf(e), nil
}

func (generatedDerivedLabel) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1DerivedLabel, error) {
	req := &derived_label.ReadDerivedLabelParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.DerivedLabel.ReadDerivedLabel(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.DerivedLabel, nil
}

func (generatedDerivedLabel) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1DerivedLabel,
	params updateParams,
) error {
	req := &derived_label.UpdateDerivedLabelParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateDerivedLabelBody{

			DerivedLabel:    m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.DerivedLabel.UpdateDerivedLabel(req)
	return err
}
func (generatedDerivedLabel) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &derived_label.DeleteDerivedLabelParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.DerivedLabel.DeleteDerivedLabel(req)
	return err
}

type generatedDerivedMetric struct{}

func (generatedDerivedMetric) slugOf(m *configv1models.Configv1DerivedMetric) string {
	return m.Slug
}

func (generatedDerivedMetric) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1DerivedMetric,
	dryRun bool,
) (string, error) {
	req := &derived_metric.CreateDerivedMetricParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateDerivedMetricRequest{
			DerivedMetric: m,
			DryRun:        dryRun,
		},
	}
	resp, err := clients.ConfigV1.DerivedMetric.CreateDerivedMetric(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.DerivedMetric
	if e == nil {
		return "", nil
	}
	return (generatedDerivedMetric{}).slugOf(e), nil
}

func (generatedDerivedMetric) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1DerivedMetric, error) {
	req := &derived_metric.ReadDerivedMetricParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.DerivedMetric.ReadDerivedMetric(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.DerivedMetric, nil
}

func (generatedDerivedMetric) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1DerivedMetric,
	params updateParams,
) error {
	req := &derived_metric.UpdateDerivedMetricParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateDerivedMetricBody{

			DerivedMetric:   m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.DerivedMetric.UpdateDerivedMetric(req)
	return err
}
func (generatedDerivedMetric) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &derived_metric.DeleteDerivedMetricParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.DerivedMetric.DeleteDerivedMetric(req)
	return err
}

type generatedDropRule struct{}

func (generatedDropRule) slugOf(m *configv1models.Configv1DropRule) string {
	return m.Slug
}

func (generatedDropRule) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1DropRule,
	dryRun bool,
) (string, error) {
	req := &drop_rule.CreateDropRuleParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateDropRuleRequest{
			DropRule: m,
			DryRun:   dryRun,
		},
	}
	resp, err := clients.ConfigV1.DropRule.CreateDropRule(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.DropRule
	if e == nil {
		return "", nil
	}
	return (generatedDropRule{}).slugOf(e), nil
}

func (generatedDropRule) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1DropRule, error) {
	req := &drop_rule.ReadDropRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.DropRule.ReadDropRule(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.DropRule, nil
}

func (generatedDropRule) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1DropRule,
	params updateParams,
) error {
	req := &drop_rule.UpdateDropRuleParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateDropRuleBody{

			DropRule:        m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.DropRule.UpdateDropRule(req)
	return err
}
func (generatedDropRule) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &drop_rule.DeleteDropRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.DropRule.DeleteDropRule(req)
	return err
}

type generatedGcpMetricsIntegration struct{}

func (generatedGcpMetricsIntegration) slugOf(m *configv1models.Configv1GcpMetricsIntegration) string {
	return m.Slug
}

func (generatedGcpMetricsIntegration) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1GcpMetricsIntegration,
	dryRun bool,
) (string, error) {
	req := &gcp_metrics_integration.CreateGcpMetricsIntegrationParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateGcpMetricsIntegrationRequest{
			GcpMetricsIntegration: m,
			DryRun:                dryRun,
		},
	}
	resp, err := clients.ConfigV1.GcpMetricsIntegration.CreateGcpMetricsIntegration(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.GcpMetricsIntegration
	if e == nil {
		return "", nil
	}
	return (generatedGcpMetricsIntegration{}).slugOf(e), nil
}

func (generatedGcpMetricsIntegration) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1GcpMetricsIntegration, error) {
	req := &gcp_metrics_integration.ReadGcpMetricsIntegrationParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.GcpMetricsIntegration.ReadGcpMetricsIntegration(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.GcpMetricsIntegration, nil
}

func (generatedGcpMetricsIntegration) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1GcpMetricsIntegration,
	params updateParams,
) error {
	req := &gcp_metrics_integration.UpdateGcpMetricsIntegrationParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateGcpMetricsIntegrationBody{

			GcpMetricsIntegration: m,
			CreateIfMissing:       params.createIfMissing,
			DryRun:                params.dryRun,
		},
	}
	_, err := clients.ConfigV1.GcpMetricsIntegration.UpdateGcpMetricsIntegration(req)
	return err
}
func (generatedGcpMetricsIntegration) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &gcp_metrics_integration.DeleteGcpMetricsIntegrationParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.GcpMetricsIntegration.DeleteGcpMetricsIntegration(req)
	return err
}

type generatedClassicDashboard struct{}

func (generatedClassicDashboard) slugOf(m *configv1models.Configv1GrafanaDashboard) string {
	return m.Slug
}

func (generatedClassicDashboard) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1GrafanaDashboard,
	dryRun bool,
) (string, error) {
	req := &grafana_dashboard.CreateGrafanaDashboardParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateGrafanaDashboardRequest{
			GrafanaDashboard: m,
			DryRun:           dryRun,
		},
	}
	resp, err := clients.ConfigV1.GrafanaDashboard.CreateGrafanaDashboard(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.GrafanaDashboard
	if e == nil {
		return "", nil
	}
	return (generatedClassicDashboard{}).slugOf(e), nil
}

func (generatedClassicDashboard) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1GrafanaDashboard, error) {
	req := &grafana_dashboard.ReadGrafanaDashboardParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.GrafanaDashboard.ReadGrafanaDashboard(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.GrafanaDashboard, nil
}

func (generatedClassicDashboard) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1GrafanaDashboard,
	params updateParams,
) error {
	req := &grafana_dashboard.UpdateGrafanaDashboardParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateGrafanaDashboardBody{

			GrafanaDashboard: m,
			CreateIfMissing:  params.createIfMissing,
			DryRun:           params.dryRun,
		},
	}
	_, err := clients.ConfigV1.GrafanaDashboard.UpdateGrafanaDashboard(req)
	return err
}
func (generatedClassicDashboard) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &grafana_dashboard.DeleteGrafanaDashboardParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.GrafanaDashboard.DeleteGrafanaDashboard(req)
	return err
}

type generatedLogAllocationConfig struct{}

// LogAllocationConfigID is the static ID of the global LogAllocationConfig singleton.
const LogAllocationConfigID = "log_allocation_config_singleton"

func (generatedLogAllocationConfig) slugOf(m *configv1models.Configv1LogAllocationConfig) string {
	return LogAllocationConfigID
}

func (generatedLogAllocationConfig) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogAllocationConfig,
	dryRun bool,
) (string, error) {
	req := &log_allocation_config.CreateLogAllocationConfigParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateLogAllocationConfigRequest{
			LogAllocationConfig: m,
			DryRun:              dryRun,
		},
	}
	resp, err := clients.ConfigV1.LogAllocationConfig.CreateLogAllocationConfig(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.LogAllocationConfig
	if e == nil {
		return "", nil
	}
	return (generatedLogAllocationConfig{}).slugOf(e), nil
}

func (generatedLogAllocationConfig) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1LogAllocationConfig, error) {
	req := &log_allocation_config.ReadLogAllocationConfigParams{
		Context: ctx,
	}
	resp, err := clients.ConfigV1.LogAllocationConfig.ReadLogAllocationConfig(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.LogAllocationConfig, nil
}

func (generatedLogAllocationConfig) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogAllocationConfig,
	params updateParams,
) error {
	req := &log_allocation_config.UpdateLogAllocationConfigParams{
		Context: ctx,

		Body: &configv1models.Configv1UpdateLogAllocationConfigRequest{

			LogAllocationConfig: m,
			CreateIfMissing:     params.createIfMissing,
			DryRun:              params.dryRun,
		},
	}
	_, err := clients.ConfigV1.LogAllocationConfig.UpdateLogAllocationConfig(req)
	return err
}
func (generatedLogAllocationConfig) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &log_allocation_config.DeleteLogAllocationConfigParams{
		Context: ctx,
	}
	_, err := clients.ConfigV1.LogAllocationConfig.DeleteLogAllocationConfig(req)
	return err
}

type generatedLogIngestConfig struct{}

// LogIngestConfigID is the static ID of the global LogIngestConfig singleton.
const LogIngestConfigID = "log_ingest_config_singleton"

func (generatedLogIngestConfig) slugOf(m *configv1models.Configv1LogIngestConfig) string {
	return LogIngestConfigID
}

func (generatedLogIngestConfig) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogIngestConfig,
	dryRun bool,
) (string, error) {
	req := &log_ingest_config.CreateLogIngestConfigParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateLogIngestConfigRequest{
			LogIngestConfig: m,
			DryRun:          dryRun,
		},
	}
	resp, err := clients.ConfigV1.LogIngestConfig.CreateLogIngestConfig(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.LogIngestConfig
	if e == nil {
		return "", nil
	}
	return (generatedLogIngestConfig{}).slugOf(e), nil
}

func (generatedLogIngestConfig) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1LogIngestConfig, error) {
	req := &log_ingest_config.ReadLogIngestConfigParams{
		Context: ctx,
	}
	resp, err := clients.ConfigV1.LogIngestConfig.ReadLogIngestConfig(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.LogIngestConfig, nil
}

func (generatedLogIngestConfig) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogIngestConfig,
	params updateParams,
) error {
	req := &log_ingest_config.UpdateLogIngestConfigParams{
		Context: ctx,

		Body: &configv1models.Configv1UpdateLogIngestConfigRequest{

			LogIngestConfig: m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.LogIngestConfig.UpdateLogIngestConfig(req)
	return err
}
func (generatedLogIngestConfig) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &log_ingest_config.DeleteLogIngestConfigParams{
		Context: ctx,
	}
	_, err := clients.ConfigV1.LogIngestConfig.DeleteLogIngestConfig(req)
	return err
}

type generatedLogScaleAction struct{}

func (generatedLogScaleAction) slugOf(m *configv1models.Configv1LogScaleAction) string {
	return m.Slug
}

func (generatedLogScaleAction) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogScaleAction,
	dryRun bool,
) (string, error) {
	req := &log_scale_action.CreateLogScaleActionParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateLogScaleActionRequest{
			LogScaleAction: m,
			DryRun:         dryRun,
		},
	}
	resp, err := clients.ConfigV1.LogScaleAction.CreateLogScaleAction(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.LogScaleAction
	if e == nil {
		return "", nil
	}
	return (generatedLogScaleAction{}).slugOf(e), nil
}

func (generatedLogScaleAction) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1LogScaleAction, error) {
	req := &log_scale_action.ReadLogScaleActionParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.LogScaleAction.ReadLogScaleAction(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.LogScaleAction, nil
}

func (generatedLogScaleAction) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogScaleAction,
	params updateParams,
) error {
	req := &log_scale_action.UpdateLogScaleActionParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateLogScaleActionBody{

			LogScaleAction:  m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.LogScaleAction.UpdateLogScaleAction(req)
	return err
}
func (generatedLogScaleAction) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &log_scale_action.DeleteLogScaleActionParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.LogScaleAction.DeleteLogScaleAction(req)
	return err
}

type generatedLogScaleAlert struct{}

func (generatedLogScaleAlert) slugOf(m *configv1models.Configv1LogScaleAlert) string {
	return m.Slug
}

func (generatedLogScaleAlert) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogScaleAlert,
	dryRun bool,
) (string, error) {
	req := &log_scale_alert.CreateLogScaleAlertParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateLogScaleAlertRequest{
			LogScaleAlert: m,
			DryRun:        dryRun,
		},
	}
	resp, err := clients.ConfigV1.LogScaleAlert.CreateLogScaleAlert(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.LogScaleAlert
	if e == nil {
		return "", nil
	}
	return (generatedLogScaleAlert{}).slugOf(e), nil
}

func (generatedLogScaleAlert) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1LogScaleAlert, error) {
	req := &log_scale_alert.ReadLogScaleAlertParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.LogScaleAlert.ReadLogScaleAlert(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.LogScaleAlert, nil
}

func (generatedLogScaleAlert) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1LogScaleAlert,
	params updateParams,
) error {
	req := &log_scale_alert.UpdateLogScaleAlertParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateLogScaleAlertBody{

			LogScaleAlert:   m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.LogScaleAlert.UpdateLogScaleAlert(req)
	return err
}
func (generatedLogScaleAlert) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &log_scale_alert.DeleteLogScaleAlertParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.LogScaleAlert.DeleteLogScaleAlert(req)
	return err
}

type generatedMappingRule struct{}

func (generatedMappingRule) slugOf(m *configv1models.Configv1MappingRule) string {
	return m.Slug
}

func (generatedMappingRule) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1MappingRule,
	dryRun bool,
) (string, error) {
	req := &mapping_rule.CreateMappingRuleParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateMappingRuleRequest{
			MappingRule: m,
			DryRun:      dryRun,
		},
	}
	resp, err := clients.ConfigV1.MappingRule.CreateMappingRule(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.MappingRule
	if e == nil {
		return "", nil
	}
	return (generatedMappingRule{}).slugOf(e), nil
}

func (generatedMappingRule) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1MappingRule, error) {
	req := &mapping_rule.ReadMappingRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.MappingRule.ReadMappingRule(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.MappingRule, nil
}

func (generatedMappingRule) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1MappingRule,
	params updateParams,
) error {
	req := &mapping_rule.UpdateMappingRuleParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateMappingRuleBody{

			MappingRule:     m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.MappingRule.UpdateMappingRule(req)
	return err
}
func (generatedMappingRule) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &mapping_rule.DeleteMappingRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.MappingRule.DeleteMappingRule(req)
	return err
}

type generatedMonitor struct{}

func (generatedMonitor) slugOf(m *configv1models.Configv1Monitor) string {
	return m.Slug
}

func (generatedMonitor) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Monitor,
	dryRun bool,
) (string, error) {
	req := &monitor.CreateMonitorParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateMonitorRequest{
			Monitor: m,
			DryRun:  dryRun,
		},
	}
	resp, err := clients.ConfigV1.Monitor.CreateMonitor(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Monitor
	if e == nil {
		return "", nil
	}
	return (generatedMonitor{}).slugOf(e), nil
}

func (generatedMonitor) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Monitor, error) {
	req := &monitor.ReadMonitorParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Monitor.ReadMonitor(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Monitor, nil
}

func (generatedMonitor) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Monitor,
	params updateParams,
) error {
	req := &monitor.UpdateMonitorParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateMonitorBody{

			Monitor:         m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Monitor.UpdateMonitor(req)
	return err
}
func (generatedMonitor) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &monitor.DeleteMonitorParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Monitor.DeleteMonitor(req)
	return err
}

type generatedNotificationPolicy struct{}

func (generatedNotificationPolicy) slugOf(m *configv1models.Configv1NotificationPolicy) string {
	return m.Slug
}

func (generatedNotificationPolicy) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1NotificationPolicy,
	dryRun bool,
) (string, error) {
	req := &notification_policy.CreateNotificationPolicyParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateNotificationPolicyRequest{
			NotificationPolicy: m,
			DryRun:             dryRun,
		},
	}
	resp, err := clients.ConfigV1.NotificationPolicy.CreateNotificationPolicy(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.NotificationPolicy
	if e == nil {
		return "", nil
	}
	return (generatedNotificationPolicy{}).slugOf(e), nil
}

func (generatedNotificationPolicy) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1NotificationPolicy, error) {
	req := &notification_policy.ReadNotificationPolicyParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.NotificationPolicy.ReadNotificationPolicy(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.NotificationPolicy, nil
}

func (generatedNotificationPolicy) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1NotificationPolicy,
	params updateParams,
) error {
	req := &notification_policy.UpdateNotificationPolicyParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateNotificationPolicyBody{

			NotificationPolicy: m,
			CreateIfMissing:    params.createIfMissing,
			DryRun:             params.dryRun,
		},
	}
	_, err := clients.ConfigV1.NotificationPolicy.UpdateNotificationPolicy(req)
	return err
}
func (generatedNotificationPolicy) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &notification_policy.DeleteNotificationPolicyParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.NotificationPolicy.DeleteNotificationPolicy(req)
	return err
}

type generatedNotifier struct{}

func (generatedNotifier) slugOf(m *configv1models.Configv1Notifier) string {
	return m.Slug
}

func (generatedNotifier) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Notifier,
	dryRun bool,
) (string, error) {
	req := &notifier.CreateNotifierParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateNotifierRequest{
			Notifier: m,
			DryRun:   dryRun,
		},
	}
	resp, err := clients.ConfigV1.Notifier.CreateNotifier(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Notifier
	if e == nil {
		return "", nil
	}
	return (generatedNotifier{}).slugOf(e), nil
}

func (generatedNotifier) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Notifier, error) {
	req := &notifier.ReadNotifierParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Notifier.ReadNotifier(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Notifier, nil
}

func (generatedNotifier) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Notifier,
	params updateParams,
) error {
	req := &notifier.UpdateNotifierParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateNotifierBody{

			Notifier:        m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Notifier.UpdateNotifier(req)
	return err
}
func (generatedNotifier) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &notifier.DeleteNotifierParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Notifier.DeleteNotifier(req)
	return err
}

type generatedOtelMetricsIngestion struct{}

// OtelMetricsIngestionID is the static ID of the global OtelMetricsIngestion singleton.
const OtelMetricsIngestionID = "otel_metrics_ingestion_singleton"

func (generatedOtelMetricsIngestion) slugOf(m *configv1models.Configv1OtelMetricsIngestion) string {
	return OtelMetricsIngestionID
}

func (generatedOtelMetricsIngestion) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1OtelMetricsIngestion,
	dryRun bool,
) (string, error) {
	req := &otel_metrics_ingestion.CreateOtelMetricsIngestionParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateOtelMetricsIngestionRequest{
			OtelMetricsIngestion: m,
			DryRun:               dryRun,
		},
	}
	resp, err := clients.ConfigV1.OtelMetricsIngestion.CreateOtelMetricsIngestion(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.OtelMetricsIngestion
	if e == nil {
		return "", nil
	}
	return (generatedOtelMetricsIngestion{}).slugOf(e), nil
}

func (generatedOtelMetricsIngestion) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1OtelMetricsIngestion, error) {
	req := &otel_metrics_ingestion.ReadOtelMetricsIngestionParams{
		Context: ctx,
	}
	resp, err := clients.ConfigV1.OtelMetricsIngestion.ReadOtelMetricsIngestion(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.OtelMetricsIngestion, nil
}

func (generatedOtelMetricsIngestion) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1OtelMetricsIngestion,
	params updateParams,
) error {
	req := &otel_metrics_ingestion.UpdateOtelMetricsIngestionParams{
		Context: ctx,

		Body: &configv1models.Configv1UpdateOtelMetricsIngestionRequest{

			OtelMetricsIngestion: m,
			CreateIfMissing:      params.createIfMissing,
			DryRun:               params.dryRun,
		},
	}
	_, err := clients.ConfigV1.OtelMetricsIngestion.UpdateOtelMetricsIngestion(req)
	return err
}
func (generatedOtelMetricsIngestion) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &otel_metrics_ingestion.DeleteOtelMetricsIngestionParams{
		Context: ctx,
	}
	_, err := clients.ConfigV1.OtelMetricsIngestion.DeleteOtelMetricsIngestion(req)
	return err
}

type generatedRecordingRule struct{}

func (generatedRecordingRule) slugOf(m *configv1models.Configv1RecordingRule) string {
	return m.Slug
}

func (generatedRecordingRule) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1RecordingRule,
	dryRun bool,
) (string, error) {
	req := &recording_rule.CreateRecordingRuleParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateRecordingRuleRequest{
			RecordingRule: m,
			DryRun:        dryRun,
		},
	}
	resp, err := clients.ConfigV1.RecordingRule.CreateRecordingRule(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.RecordingRule
	if e == nil {
		return "", nil
	}
	return (generatedRecordingRule{}).slugOf(e), nil
}

func (generatedRecordingRule) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1RecordingRule, error) {
	req := &recording_rule.ReadRecordingRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.RecordingRule.ReadRecordingRule(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.RecordingRule, nil
}

func (generatedRecordingRule) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1RecordingRule,
	params updateParams,
) error {
	req := &recording_rule.UpdateRecordingRuleParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateRecordingRuleBody{

			RecordingRule:   m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.RecordingRule.UpdateRecordingRule(req)
	return err
}
func (generatedRecordingRule) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &recording_rule.DeleteRecordingRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.RecordingRule.DeleteRecordingRule(req)
	return err
}

type generatedResourcePools struct{}

// ResourcePoolsID is the static ID of the global ResourcePools singleton.
const ResourcePoolsID = "resource_pool_singleton"

func (generatedResourcePools) slugOf(m *configv1models.Configv1ResourcePools) string {
	return ResourcePoolsID
}

func (generatedResourcePools) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1ResourcePools,
	dryRun bool,
) (string, error) {
	req := &resource_pools.CreateResourcePoolsParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateResourcePoolsRequest{
			ResourcePools: m,
			DryRun:        dryRun,
		},
	}
	resp, err := clients.ConfigV1.ResourcePools.CreateResourcePools(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.ResourcePools
	if e == nil {
		return "", nil
	}
	return (generatedResourcePools{}).slugOf(e), nil
}

func (generatedResourcePools) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1ResourcePools, error) {
	req := &resource_pools.ReadResourcePoolsParams{
		Context: ctx,
	}
	resp, err := clients.ConfigV1.ResourcePools.ReadResourcePools(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.ResourcePools, nil
}

func (generatedResourcePools) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1ResourcePools,
	params updateParams,
) error {
	req := &resource_pools.UpdateResourcePoolsParams{
		Context: ctx,

		Body: &configv1models.Configv1UpdateResourcePoolsRequest{

			ResourcePools:   m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.ResourcePools.UpdateResourcePools(req)
	return err
}
func (generatedResourcePools) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &resource_pools.DeleteResourcePoolsParams{
		Context: ctx,
	}
	_, err := clients.ConfigV1.ResourcePools.DeleteResourcePools(req)
	return err
}

type generatedRollupRule struct{}

func (generatedRollupRule) slugOf(m *configv1models.Configv1RollupRule) string {
	return m.Slug
}

func (generatedRollupRule) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1RollupRule,
	dryRun bool,
) (string, error) {
	req := &rollup_rule.CreateRollupRuleParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateRollupRuleRequest{
			RollupRule: m,
			DryRun:     dryRun,
		},
	}
	resp, err := clients.ConfigV1.RollupRule.CreateRollupRule(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.RollupRule
	if e == nil {
		return "", nil
	}
	return (generatedRollupRule{}).slugOf(e), nil
}

func (generatedRollupRule) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1RollupRule, error) {
	req := &rollup_rule.ReadRollupRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.RollupRule.ReadRollupRule(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.RollupRule, nil
}

func (generatedRollupRule) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1RollupRule,
	params updateParams,
) error {
	req := &rollup_rule.UpdateRollupRuleParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateRollupRuleBody{

			RollupRule:      m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.RollupRule.UpdateRollupRule(req)
	return err
}
func (generatedRollupRule) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &rollup_rule.DeleteRollupRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.RollupRule.DeleteRollupRule(req)
	return err
}

type generatedSLO struct{}

func (generatedSLO) slugOf(m *configv1models.Configv1SLO) string {
	return m.Slug
}

func (generatedSLO) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1SLO,
	dryRun bool,
) (string, error) {
	req := &slo.CreateSLOParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateSLORequest{
			SLO:    m,
			DryRun: dryRun,
		},
	}
	resp, err := clients.ConfigV1.SLO.CreateSLO(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.SLO
	if e == nil {
		return "", nil
	}
	return (generatedSLO{}).slugOf(e), nil
}

func (generatedSLO) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1SLO, error) {
	req := &slo.ReadSLOParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.SLO.ReadSLO(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.SLO, nil
}

func (generatedSLO) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1SLO,
	params updateParams,
) error {
	req := &slo.UpdateSLOParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateSLOBody{

			SLO:             m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.SLO.UpdateSLO(req)
	return err
}
func (generatedSLO) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &slo.DeleteSLOParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.SLO.DeleteSLO(req)
	return err
}

type generatedServiceAccount struct{}

func (generatedServiceAccount) slugOf(m *configv1models.Configv1ServiceAccount) string {
	return m.Slug
}

func (generatedServiceAccount) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1ServiceAccount,
	dryRun bool,
) (string, error) {
	req := &service_account.CreateServiceAccountParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateServiceAccountRequest{
			ServiceAccount: m,
			DryRun:         dryRun,
		},
	}
	resp, err := clients.ConfigV1.ServiceAccount.CreateServiceAccount(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.ServiceAccount
	if e == nil {
		return "", nil
	}
	return (generatedServiceAccount{}).slugOf(e), nil
}

func (generatedServiceAccount) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1ServiceAccount, error) {
	req := &service_account.ReadServiceAccountParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.ServiceAccount.ReadServiceAccount(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.ServiceAccount, nil
}

func (generatedServiceAccount) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &service_account.DeleteServiceAccountParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.ServiceAccount.DeleteServiceAccount(req)
	return err
}

type generatedTeam struct{}

func (generatedTeam) slugOf(m *configv1models.Configv1Team) string {
	return m.Slug
}

func (generatedTeam) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Team,
	dryRun bool,
) (string, error) {
	req := &team.CreateTeamParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateTeamRequest{
			Team:   m,
			DryRun: dryRun,
		},
	}
	resp, err := clients.ConfigV1.Team.CreateTeam(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.Team
	if e == nil {
		return "", nil
	}
	return (generatedTeam{}).slugOf(e), nil
}

func (generatedTeam) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1Team, error) {
	req := &team.ReadTeamParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.Team.ReadTeam(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.Team, nil
}

func (generatedTeam) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1Team,
	params updateParams,
) error {
	req := &team.UpdateTeamParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateTeamBody{

			Team:            m,
			CreateIfMissing: params.createIfMissing,
			DryRun:          params.dryRun,
		},
	}
	_, err := clients.ConfigV1.Team.UpdateTeam(req)
	return err
}
func (generatedTeam) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &team.DeleteTeamParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.Team.DeleteTeam(req)
	return err
}

type generatedTraceJaegerRemoteSamplingStrategy struct{}

func (generatedTraceJaegerRemoteSamplingStrategy) slugOf(m *configv1models.Configv1TraceJaegerRemoteSamplingStrategy) string {
	return m.Slug
}

func (generatedTraceJaegerRemoteSamplingStrategy) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1TraceJaegerRemoteSamplingStrategy,
	dryRun bool,
) (string, error) {
	req := &trace_jaeger_remote_sampling_strategy.CreateTraceJaegerRemoteSamplingStrategyParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateTraceJaegerRemoteSamplingStrategyRequest{
			TraceJaegerRemoteSamplingStrategy: m,
			DryRun:                            dryRun,
		},
	}
	resp, err := clients.ConfigV1.TraceJaegerRemoteSamplingStrategy.CreateTraceJaegerRemoteSamplingStrategy(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.TraceJaegerRemoteSamplingStrategy
	if e == nil {
		return "", nil
	}
	return (generatedTraceJaegerRemoteSamplingStrategy{}).slugOf(e), nil
}

func (generatedTraceJaegerRemoteSamplingStrategy) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1TraceJaegerRemoteSamplingStrategy, error) {
	req := &trace_jaeger_remote_sampling_strategy.ReadTraceJaegerRemoteSamplingStrategyParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.TraceJaegerRemoteSamplingStrategy.ReadTraceJaegerRemoteSamplingStrategy(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.TraceJaegerRemoteSamplingStrategy, nil
}

func (generatedTraceJaegerRemoteSamplingStrategy) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1TraceJaegerRemoteSamplingStrategy,
	params updateParams,
) error {
	req := &trace_jaeger_remote_sampling_strategy.UpdateTraceJaegerRemoteSamplingStrategyParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody{

			TraceJaegerRemoteSamplingStrategy: m,
			CreateIfMissing:                   params.createIfMissing,
			DryRun:                            params.dryRun,
		},
	}
	_, err := clients.ConfigV1.TraceJaegerRemoteSamplingStrategy.UpdateTraceJaegerRemoteSamplingStrategy(req)
	return err
}
func (generatedTraceJaegerRemoteSamplingStrategy) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &trace_jaeger_remote_sampling_strategy.DeleteTraceJaegerRemoteSamplingStrategyParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.TraceJaegerRemoteSamplingStrategy.DeleteTraceJaegerRemoteSamplingStrategy(req)
	return err
}

type generatedTraceMetricsRule struct{}

func (generatedTraceMetricsRule) slugOf(m *configv1models.Configv1TraceMetricsRule) string {
	return m.Slug
}

func (generatedTraceMetricsRule) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1TraceMetricsRule,
	dryRun bool,
) (string, error) {
	req := &trace_metrics_rule.CreateTraceMetricsRuleParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateTraceMetricsRuleRequest{
			TraceMetricsRule: m,
			DryRun:           dryRun,
		},
	}
	resp, err := clients.ConfigV1.TraceMetricsRule.CreateTraceMetricsRule(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.TraceMetricsRule
	if e == nil {
		return "", nil
	}
	return (generatedTraceMetricsRule{}).slugOf(e), nil
}

func (generatedTraceMetricsRule) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1TraceMetricsRule, error) {
	req := &trace_metrics_rule.ReadTraceMetricsRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	resp, err := clients.ConfigV1.TraceMetricsRule.ReadTraceMetricsRule(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.TraceMetricsRule, nil
}

func (generatedTraceMetricsRule) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1TraceMetricsRule,
	params updateParams,
) error {
	req := &trace_metrics_rule.UpdateTraceMetricsRuleParams{
		Context: ctx,
		Slug:    m.Slug,

		Body: &configv1models.ConfigV1UpdateTraceMetricsRuleBody{

			TraceMetricsRule: m,
			CreateIfMissing:  params.createIfMissing,
			DryRun:           params.dryRun,
		},
	}
	_, err := clients.ConfigV1.TraceMetricsRule.UpdateTraceMetricsRule(req)
	return err
}
func (generatedTraceMetricsRule) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &trace_metrics_rule.DeleteTraceMetricsRuleParams{
		Context: ctx,
		Slug:    slug,
	}
	_, err := clients.ConfigV1.TraceMetricsRule.DeleteTraceMetricsRule(req)
	return err
}

type generatedTraceTailSamplingRules struct{}

// TraceTailSamplingRulesID is the static ID of the global TraceTailSamplingRules singleton.
const TraceTailSamplingRulesID = "trace_tail_sampling_singleton"

func (generatedTraceTailSamplingRules) slugOf(m *configv1models.Configv1TraceTailSamplingRules) string {
	return TraceTailSamplingRulesID
}

func (generatedTraceTailSamplingRules) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1TraceTailSamplingRules,
	dryRun bool,
) (string, error) {
	req := &trace_tail_sampling_rules.CreateTraceTailSamplingRulesParams{
		Context: ctx,
		Body: &configv1models.Configv1CreateTraceTailSamplingRulesRequest{
			TraceTailSamplingRules: m,
			DryRun:                 dryRun,
		},
	}
	resp, err := clients.ConfigV1.TraceTailSamplingRules.CreateTraceTailSamplingRules(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.TraceTailSamplingRules
	if e == nil {
		return "", nil
	}
	return (generatedTraceTailSamplingRules{}).slugOf(e), nil
}

func (generatedTraceTailSamplingRules) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configv1models.Configv1TraceTailSamplingRules, error) {
	req := &trace_tail_sampling_rules.ReadTraceTailSamplingRulesParams{
		Context: ctx,
	}
	resp, err := clients.ConfigV1.TraceTailSamplingRules.ReadTraceTailSamplingRules(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.TraceTailSamplingRules, nil
}

func (generatedTraceTailSamplingRules) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configv1models.Configv1TraceTailSamplingRules,
	params updateParams,
) error {
	req := &trace_tail_sampling_rules.UpdateTraceTailSamplingRulesParams{
		Context: ctx,

		Body: &configv1models.Configv1UpdateTraceTailSamplingRulesRequest{

			TraceTailSamplingRules: m,
			CreateIfMissing:        params.createIfMissing,
			DryRun:                 params.dryRun,
		},
	}
	_, err := clients.ConfigV1.TraceTailSamplingRules.UpdateTraceTailSamplingRules(req)
	return err
}
func (generatedTraceTailSamplingRules) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &trace_tail_sampling_rules.DeleteTraceTailSamplingRulesParams{
		Context: ctx,
	}
	_, err := clients.ConfigV1.TraceTailSamplingRules.DeleteTraceTailSamplingRules(req)
	return err
}

type generatedUnstableConsumptionConfig struct{}

// ConsumptionConfigID is the static ID of the global ConsumptionConfig singleton.
const ConsumptionConfigID = "consumption_config_singleton"

func (generatedUnstableConsumptionConfig) slugOf(m *configunstablemodels.ConfigunstableConsumptionConfig) string {
	return ConsumptionConfigID
}

func (generatedUnstableConsumptionConfig) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *configunstablemodels.ConfigunstableConsumptionConfig,
	dryRun bool,
) (string, error) {
	req := &consumption_config.CreateConsumptionConfigParams{
		Context: ctx,
		Body: &configunstablemodels.ConfigunstableCreateConsumptionConfigRequest{
			ConsumptionConfig: m,
			DryRun:            dryRun,
		},
	}
	resp, err := clients.ConfigUnstable.ConsumptionConfig.CreateConsumptionConfig(req)
	if err != nil {
		return "", err
	}
	e := resp.Payload.ConsumptionConfig
	if e == nil {
		return "", nil
	}
	return (generatedUnstableConsumptionConfig{}).slugOf(e), nil
}

func (generatedUnstableConsumptionConfig) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*configunstablemodels.ConfigunstableConsumptionConfig, error) {
	req := &consumption_config.ReadConsumptionConfigParams{
		Context: ctx,
	}
	resp, err := clients.ConfigUnstable.ConsumptionConfig.ReadConsumptionConfig(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.ConsumptionConfig, nil
}

func (generatedUnstableConsumptionConfig) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *configunstablemodels.ConfigunstableConsumptionConfig,
	params updateParams,
) error {
	req := &consumption_config.UpdateConsumptionConfigParams{
		Context: ctx,

		Body: &configunstablemodels.ConfigunstableUpdateConsumptionConfigRequest{

			ConsumptionConfig: m,
			CreateIfMissing:   params.createIfMissing,
			DryRun:            params.dryRun,
		},
	}
	_, err := clients.ConfigUnstable.ConsumptionConfig.UpdateConsumptionConfig(req)
	return err
}
func (generatedUnstableConsumptionConfig) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &consumption_config.DeleteConsumptionConfigParams{
		Context: ctx,
	}
	_, err := clients.ConfigUnstable.ConsumptionConfig.DeleteConsumptionConfig(req)
	return err
}
