// Copyright 2024 Chronosphere Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"strings"

	"github.com/iancoleman/strcase"

	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/registry"
)

func main() {
	if err := run(); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}

func run() error {
	v1 := api{
		Package:         "configv1",
		SwaggerPrefix:   "Configv1",
		Client:          "configClient",
		RequireUnstable: false,
	}
	unstable := api{
		Package:         "configunstable",
		SwaggerPrefix:   "Configunstable",
		Client:          "configUnstableClient",
		RequireUnstable: true,
	}

	var entityTypes []entityType
	for _, e := range registry.AllEntities(registry.V1) {
		// Ignore service attributes from generation as it has a different
		// client structure for now.
		et := newEntityType(v1, e)
		entityTypes = append(entityTypes, et)
	}
	entityTypes = append(entityTypes, newClassicDashboard(v1))
	includesUnstable := false
	for _, e := range registry.NamedEntities(registry.Unstable) {
		entityTypes = append(entityTypes, newEntityType(unstable, e))
		includesUnstable = true
	}

	b := &bytes.Buffer{}
	if err := fileTemplate.Execute(b, data{
		EntityTypes:      entityTypes,
		IncludesUnstable: includesUnstable,
	}); err != nil {
		return err
	}
	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}
	return os.WriteFile("pagination.gen.go", formatted, 0o644)
}

type api struct {
	Package         string
	SwaggerPrefix   string
	GoPrefix        string
	Client          string
	RequireUnstable bool
}

type entityType struct {
	API       api
	Singleton bool
	Singular  string
	Plural    string
	// This will normally be the same as Plural, but some entities have irregular plural forms.
	PayloadPlural        string
	SwaggerClient        string
	SwaggerClientPackage string
	SwaggerModel         string
	Disable              bool
	RequireFilterAPIs    bool
}

func newEntityType(a api, e registry.Resource) entityType {
	requireFilterAPIs := true
	if len(e.EntityLinkedSingletonSlugField) > 0 {
		requireFilterAPIs = false
	}
	et := entityType{
		API:                  a,
		Singleton:            e.SingletonID != "",
		Singular:             e.Entity,
		Plural:               plural(e.Entity),
		PayloadPlural:        plural(e.Entity),
		SwaggerClientPackage: strcase.ToSnake(e.Entity),
		Disable:              e.DisableExportImport,
		SwaggerModel:         e.Entity,
		RequireFilterAPIs:    requireFilterAPIs,
	}

	if e.Name == "slo" {
		et.PayloadPlural = "Slos"
	}

	return et
}

func newClassicDashboard(a api) entityType {
	e := newEntityType(a, registry.Resource{
		Entity: "ClassicDashboard",
	})
	e.SwaggerModel = "GrafanaDashboard"
	return e
}

func plural(e string) string {
	if strings.HasSuffix(e, "y") {
		return strings.TrimSuffix(e, "y") + "ies"
	}
	return e + "s"
}

type data struct {
	EntityTypes      []entityType
	IncludesUnstable bool
}

var fileTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package pagination

import (
	"context"

	{{- if .IncludesUnstable }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable"
	{{- end }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1"
	{{- if .IncludesUnstable }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/unstable"
	configunstablemodels "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable/models"
	{{- end }}
	configv1models "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/models"
	{{- range .EntityTypes }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/{{.API.Package}}/client/{{.SwaggerClientPackage}}"
	{{- end }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/clienterror"
)

{{range .EntityTypes}}

{{if .Singleton}}
func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Singular}}(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	opts... func(*{{.SwaggerClientPackage}}.Read{{.Singular}}Params),
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	p := &{{.SwaggerClientPackage}}.Read{{.Singular}}Params{
		Context: ctx,
	}
	for _, opt := range opts {
		opt(p)
	}
	resp, err := client.{{.Singular}}.Read{{.Singular}}(p)
	if err != nil {
		if clienterror.IsNotFound(err) {
			return nil, nil
		}
		return nil, err
	}
	return []*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}{
		resp.Payload.{{.Singular}},
	}, nil
}
{{else}}
func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}(
	ctx context.Context,
	client *{{.API.Package}}.Client,
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	return List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(ctx, client, Filter{})
}

{{if .RequireFilterAPIs}}
func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}BySlugs(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	slugs []string,
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	return List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByNames(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	names []string,
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	return List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(ctx, client, Filter{
		Names: names,
	})
}
{{- end}}

func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	f Filter,
	opts... func(*{{.SwaggerClientPackage}}.List{{.Plural}}Params),
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	{{- if .Disable}}
		return nil, nil
	{{- else}}
	{{- if .API.RequireUnstable}}
	if !unstable.Enabled() {
		return nil, nil
	}
	{{- end}}
	var (
		nextToken string
		result []*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}
	)
	for {
		p := &{{.SwaggerClientPackage}}.List{{.Plural}}Params{
			Context: ctx,
			PageToken: &nextToken,
		{{if .RequireFilterAPIs}}
			Slugs: f.Slugs,
			Names: f.Names,
		{{- end}}
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.{{.Singular}}.List{{.Plural}}(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.{{.PayloadPlural}} {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
	{{- end}}
}
{{end}}
{{end -}}
`))
