package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"strings"

	"github.com/iancoleman/strcase"

	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/registry"
)

func main() {
	if err := run(); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}

func run() error {
	v1 := api{
		Package:         "configv1",
		SwaggerPrefix:   "Configv1",
		Client:          "configClient",
		RequireUnstable: false,
	}
	unstable := api{
		Package:         "configunstable",
		SwaggerPrefix:   "Configunstable",
		Client:          "configUnstableClient",
		RequireUnstable: true,
	}

	var entityTypes []entityType
	for _, e := range registry.StandardEntities(registry.V1) {
		entityTypes = append(entityTypes, newEntityType(v1, e))
	}
	entityTypes = append(entityTypes, newClassicDashboard(v1))
	includesUnstable := false
	for _, e := range registry.StandardEntities(registry.Unstable) {
		entityTypes = append(entityTypes, newEntityType(unstable, e))
		includesUnstable = true
	}

	b := &bytes.Buffer{}
	if err := fileTemplate.Execute(b, data{
		EntityTypes:      entityTypes,
		IncludesUnstable: includesUnstable,
	}); err != nil {
		return err
	}
	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}
	return os.WriteFile("pagination.gen.go", formatted, 0o644)
}

type api struct {
	Package         string
	SwaggerPrefix   string
	GoPrefix        string
	Client          string
	RequireUnstable bool
}

type entityType struct {
	API                  api
	Singular             string
	Plural               string
	SwaggerClient        string
	SwaggerClientPackage string
	SwaggerModel         string
	Disable              bool
}

func newEntityType(a api, e registry.Resource) entityType {
	return entityType{
		API:                  a,
		Singular:             e.Entity,
		Plural:               plural(e.Entity),
		SwaggerClientPackage: strcase.ToSnake(e.Entity),
		Disable:              e.DisableExportImport,
		SwaggerModel:         e.Entity,
	}
}

func newClassicDashboard(a api) entityType {
	e := newEntityType(a, registry.Resource{
		Entity: "ClassicDashboard",
	})
	e.SwaggerModel = "GrafanaDashboard"
	return e
}

func plural(e string) string {
	if strings.HasSuffix(e, "y") {
		return strings.TrimSuffix(e, "y") + "ies"
	}
	return e + "s"
}

type data struct {
	EntityTypes      []entityType
	IncludesUnstable bool
}

var fileTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package pagination

import (
	"context"

	{{- if .IncludesUnstable }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable"
	{{- end }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1"
	{{- if .IncludesUnstable }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/unstable"
	configunstablemodels "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable/models"
	{{- end }}
	configv1models "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/models"
	{{- range .EntityTypes }}
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/{{.API.Package}}/client/{{.SwaggerClientPackage}}"
	{{- end }}
)

{{range .EntityTypes}}

func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}(
	ctx context.Context,
	client *{{.API.Package}}.Client,
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	return List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(ctx, client, Filter{})
}

func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}BySlugs(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	slugs []string,
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	return List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByNames(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	names []string,
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	return List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(ctx, client, Filter{
		Names: names,
	})
}

func List{{if .API.RequireUnstable}}Unstable{{end}}{{.Plural}}ByFilter(
	ctx context.Context,
	client *{{.API.Package}}.Client,
	f Filter,
	opts... func(*{{.SwaggerClientPackage}}.List{{.Plural}}Params),
) ([]*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}, error) {
	{{- if .Disable}}
		return nil, nil
	{{- else}}
	{{- if .API.RequireUnstable}}
	if !unstable.Enabled() {
		return nil, nil
	}
	{{- end}}
	var (
		nextToken string
		result []*{{.API.Package}}models.{{.API.SwaggerPrefix}}{{.SwaggerModel}}
	)
	for {
		p := &{{.SwaggerClientPackage}}.List{{.Plural}}Params{
			Context: ctx,
			PageToken: &nextToken,
			Slugs: f.Slugs,
			Names: f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.{{.Singular}}.List{{.Plural}}(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.{{.Plural}} {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
	{{- end}}
}
{{end -}}
`))
