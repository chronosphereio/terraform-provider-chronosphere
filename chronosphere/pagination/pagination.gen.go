// Code generated by go generate; DO NOT EDIT.
package pagination

import (
	"context"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable/client/gcp_metrics_integration"
	configunstablemodels "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configunstable/models"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/bucket"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/classic_dashboard"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/collection"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/dashboard"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/dataset"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/derived_label"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/derived_metric"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/drop_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/grafana_dashboard"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/mapping_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/monitor"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/notification_policy"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/notifier"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/recording_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/rollup_rule"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/service_account"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/team"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/trace_jaeger_remote_sampling_strategy"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/trace_metrics_rule"
	configv1models "github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/models"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/unstable"
)

func ListBuckets(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Bucket, error) {
	return ListBucketsByFilter(ctx, client, Filter{})
}

func ListBucketsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Bucket, error) {
	return ListBucketsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListBucketsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Bucket, error) {
	return ListBucketsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListBucketsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*bucket.ListBucketsParams),
) ([]*configv1models.Configv1Bucket, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Bucket
	)
	for {
		p := &bucket.ListBucketsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Bucket.ListBuckets(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Buckets {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListCollections(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Collection, error) {
	return ListCollectionsByFilter(ctx, client, Filter{})
}

func ListCollectionsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Collection, error) {
	return ListCollectionsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListCollectionsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Collection, error) {
	return ListCollectionsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListCollectionsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*collection.ListCollectionsParams),
) ([]*configv1models.Configv1Collection, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Collection
	)
	for {
		p := &collection.ListCollectionsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Collection.ListCollections(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Collections {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListDashboards(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Dashboard, error) {
	return ListDashboardsByFilter(ctx, client, Filter{})
}

func ListDashboardsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Dashboard, error) {
	return ListDashboardsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListDashboardsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Dashboard, error) {
	return ListDashboardsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListDashboardsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*dashboard.ListDashboardsParams),
) ([]*configv1models.Configv1Dashboard, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Dashboard
	)
	for {
		p := &dashboard.ListDashboardsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Dashboard.ListDashboards(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Dashboards {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListDatasets(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Dataset, error) {
	return ListDatasetsByFilter(ctx, client, Filter{})
}

func ListDatasetsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Dataset, error) {
	return ListDatasetsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListDatasetsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Dataset, error) {
	return ListDatasetsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListDatasetsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*dataset.ListDatasetsParams),
) ([]*configv1models.Configv1Dataset, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Dataset
	)
	for {
		p := &dataset.ListDatasetsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Dataset.ListDatasets(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Datasets {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListDerivedLabels(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1DerivedLabel, error) {
	return ListDerivedLabelsByFilter(ctx, client, Filter{})
}

func ListDerivedLabelsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1DerivedLabel, error) {
	return ListDerivedLabelsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListDerivedLabelsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1DerivedLabel, error) {
	return ListDerivedLabelsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListDerivedLabelsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*derived_label.ListDerivedLabelsParams),
) ([]*configv1models.Configv1DerivedLabel, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1DerivedLabel
	)
	for {
		p := &derived_label.ListDerivedLabelsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.DerivedLabel.ListDerivedLabels(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.DerivedLabels {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListDerivedMetrics(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1DerivedMetric, error) {
	return ListDerivedMetricsByFilter(ctx, client, Filter{})
}

func ListDerivedMetricsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1DerivedMetric, error) {
	return ListDerivedMetricsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListDerivedMetricsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1DerivedMetric, error) {
	return ListDerivedMetricsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListDerivedMetricsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*derived_metric.ListDerivedMetricsParams),
) ([]*configv1models.Configv1DerivedMetric, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1DerivedMetric
	)
	for {
		p := &derived_metric.ListDerivedMetricsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.DerivedMetric.ListDerivedMetrics(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.DerivedMetrics {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListDropRules(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1DropRule, error) {
	return ListDropRulesByFilter(ctx, client, Filter{})
}

func ListDropRulesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1DropRule, error) {
	return ListDropRulesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListDropRulesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1DropRule, error) {
	return ListDropRulesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListDropRulesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*drop_rule.ListDropRulesParams),
) ([]*configv1models.Configv1DropRule, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1DropRule
	)
	for {
		p := &drop_rule.ListDropRulesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.DropRule.ListDropRules(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.DropRules {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListGrafanaDashboards(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	return ListGrafanaDashboardsByFilter(ctx, client, Filter{})
}

func ListGrafanaDashboardsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	return ListGrafanaDashboardsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListGrafanaDashboardsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	return ListGrafanaDashboardsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListGrafanaDashboardsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*grafana_dashboard.ListGrafanaDashboardsParams),
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1GrafanaDashboard
	)
	for {
		p := &grafana_dashboard.ListGrafanaDashboardsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.GrafanaDashboard.ListGrafanaDashboards(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.GrafanaDashboards {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListMappingRules(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1MappingRule, error) {
	return ListMappingRulesByFilter(ctx, client, Filter{})
}

func ListMappingRulesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1MappingRule, error) {
	return ListMappingRulesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListMappingRulesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1MappingRule, error) {
	return ListMappingRulesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListMappingRulesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*mapping_rule.ListMappingRulesParams),
) ([]*configv1models.Configv1MappingRule, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1MappingRule
	)
	for {
		p := &mapping_rule.ListMappingRulesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.MappingRule.ListMappingRules(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.MappingRules {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListMonitors(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Monitor, error) {
	return ListMonitorsByFilter(ctx, client, Filter{})
}

func ListMonitorsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Monitor, error) {
	return ListMonitorsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListMonitorsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Monitor, error) {
	return ListMonitorsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListMonitorsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*monitor.ListMonitorsParams),
) ([]*configv1models.Configv1Monitor, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Monitor
	)
	for {
		p := &monitor.ListMonitorsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Monitor.ListMonitors(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Monitors {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListNotificationPolicies(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1NotificationPolicy, error) {
	return ListNotificationPoliciesByFilter(ctx, client, Filter{})
}

func ListNotificationPoliciesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1NotificationPolicy, error) {
	return ListNotificationPoliciesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListNotificationPoliciesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1NotificationPolicy, error) {
	return ListNotificationPoliciesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListNotificationPoliciesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*notification_policy.ListNotificationPoliciesParams),
) ([]*configv1models.Configv1NotificationPolicy, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1NotificationPolicy
	)
	for {
		p := &notification_policy.ListNotificationPoliciesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.NotificationPolicy.ListNotificationPolicies(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.NotificationPolicies {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListNotifiers(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Notifier, error) {
	return ListNotifiersByFilter(ctx, client, Filter{})
}

func ListNotifiersBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Notifier, error) {
	return ListNotifiersByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListNotifiersByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Notifier, error) {
	return ListNotifiersByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListNotifiersByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*notifier.ListNotifiersParams),
) ([]*configv1models.Configv1Notifier, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Notifier
	)
	for {
		p := &notifier.ListNotifiersParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Notifier.ListNotifiers(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Notifiers {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListRecordingRules(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1RecordingRule, error) {
	return ListRecordingRulesByFilter(ctx, client, Filter{})
}

func ListRecordingRulesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1RecordingRule, error) {
	return ListRecordingRulesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListRecordingRulesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1RecordingRule, error) {
	return ListRecordingRulesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListRecordingRulesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*recording_rule.ListRecordingRulesParams),
) ([]*configv1models.Configv1RecordingRule, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1RecordingRule
	)
	for {
		p := &recording_rule.ListRecordingRulesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.RecordingRule.ListRecordingRules(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.RecordingRules {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListRollupRules(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1RollupRule, error) {
	return ListRollupRulesByFilter(ctx, client, Filter{})
}

func ListRollupRulesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1RollupRule, error) {
	return ListRollupRulesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListRollupRulesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1RollupRule, error) {
	return ListRollupRulesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListRollupRulesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*rollup_rule.ListRollupRulesParams),
) ([]*configv1models.Configv1RollupRule, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1RollupRule
	)
	for {
		p := &rollup_rule.ListRollupRulesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.RollupRule.ListRollupRules(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.RollupRules {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListServiceAccounts(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1ServiceAccount, error) {
	return ListServiceAccountsByFilter(ctx, client, Filter{})
}

func ListServiceAccountsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1ServiceAccount, error) {
	return ListServiceAccountsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListServiceAccountsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1ServiceAccount, error) {
	return ListServiceAccountsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListServiceAccountsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*service_account.ListServiceAccountsParams),
) ([]*configv1models.Configv1ServiceAccount, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1ServiceAccount
	)
	for {
		p := &service_account.ListServiceAccountsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.ServiceAccount.ListServiceAccounts(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.ServiceAccounts {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListTeams(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1Team, error) {
	return ListTeamsByFilter(ctx, client, Filter{})
}

func ListTeamsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1Team, error) {
	return ListTeamsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListTeamsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1Team, error) {
	return ListTeamsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListTeamsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*team.ListTeamsParams),
) ([]*configv1models.Configv1Team, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1Team
	)
	for {
		p := &team.ListTeamsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.Team.ListTeams(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.Teams {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListTraceJaegerRemoteSamplingStrategies(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1TraceJaegerRemoteSamplingStrategy, error) {
	return ListTraceJaegerRemoteSamplingStrategiesByFilter(ctx, client, Filter{})
}

func ListTraceJaegerRemoteSamplingStrategiesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1TraceJaegerRemoteSamplingStrategy, error) {
	return ListTraceJaegerRemoteSamplingStrategiesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListTraceJaegerRemoteSamplingStrategiesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1TraceJaegerRemoteSamplingStrategy, error) {
	return ListTraceJaegerRemoteSamplingStrategiesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListTraceJaegerRemoteSamplingStrategiesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*trace_jaeger_remote_sampling_strategy.ListTraceJaegerRemoteSamplingStrategiesParams),
) ([]*configv1models.Configv1TraceJaegerRemoteSamplingStrategy, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1TraceJaegerRemoteSamplingStrategy
	)
	for {
		p := &trace_jaeger_remote_sampling_strategy.ListTraceJaegerRemoteSamplingStrategiesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.TraceJaegerRemoteSamplingStrategy.ListTraceJaegerRemoteSamplingStrategies(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.TraceJaegerRemoteSamplingStrategies {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListTraceMetricsRules(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1TraceMetricsRule, error) {
	return ListTraceMetricsRulesByFilter(ctx, client, Filter{})
}

func ListTraceMetricsRulesBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1TraceMetricsRule, error) {
	return ListTraceMetricsRulesByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListTraceMetricsRulesByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1TraceMetricsRule, error) {
	return ListTraceMetricsRulesByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListTraceMetricsRulesByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*trace_metrics_rule.ListTraceMetricsRulesParams),
) ([]*configv1models.Configv1TraceMetricsRule, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1TraceMetricsRule
	)
	for {
		p := &trace_metrics_rule.ListTraceMetricsRulesParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.TraceMetricsRule.ListTraceMetricsRules(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.TraceMetricsRules {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListClassicDashboards(
	ctx context.Context,
	client *configv1.Client,
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	return ListClassicDashboardsByFilter(ctx, client, Filter{})
}

func ListClassicDashboardsBySlugs(
	ctx context.Context,
	client *configv1.Client,
	slugs []string,
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	return ListClassicDashboardsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListClassicDashboardsByNames(
	ctx context.Context,
	client *configv1.Client,
	names []string,
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	return ListClassicDashboardsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListClassicDashboardsByFilter(
	ctx context.Context,
	client *configv1.Client,
	f Filter,
	opts ...func(*classic_dashboard.ListClassicDashboardsParams),
) ([]*configv1models.Configv1GrafanaDashboard, error) {
	var (
		nextToken string
		result    []*configv1models.Configv1GrafanaDashboard
	)
	for {
		p := &classic_dashboard.ListClassicDashboardsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.ClassicDashboard.ListClassicDashboards(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.ClassicDashboards {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}

func ListUnstableGcpMetricsIntegrations(
	ctx context.Context,
	client *configunstable.Client,
) ([]*configunstablemodels.ConfigunstableGcpMetricsIntegration, error) {
	return ListUnstableGcpMetricsIntegrationsByFilter(ctx, client, Filter{})
}

func ListUnstableGcpMetricsIntegrationsBySlugs(
	ctx context.Context,
	client *configunstable.Client,
	slugs []string,
) ([]*configunstablemodels.ConfigunstableGcpMetricsIntegration, error) {
	return ListUnstableGcpMetricsIntegrationsByFilter(ctx, client, Filter{
		Slugs: slugs,
	})
}

func ListUnstableGcpMetricsIntegrationsByNames(
	ctx context.Context,
	client *configunstable.Client,
	names []string,
) ([]*configunstablemodels.ConfigunstableGcpMetricsIntegration, error) {
	return ListUnstableGcpMetricsIntegrationsByFilter(ctx, client, Filter{
		Names: names,
	})
}

func ListUnstableGcpMetricsIntegrationsByFilter(
	ctx context.Context,
	client *configunstable.Client,
	f Filter,
	opts ...func(*gcp_metrics_integration.ListGcpMetricsIntegrationsParams),
) ([]*configunstablemodels.ConfigunstableGcpMetricsIntegration, error) {
	if !unstable.Enabled() {
		return nil, nil
	}
	var (
		nextToken string
		result    []*configunstablemodels.ConfigunstableGcpMetricsIntegration
	)
	for {
		p := &gcp_metrics_integration.ListGcpMetricsIntegrationsParams{
			Context:   ctx,
			PageToken: &nextToken,
			Slugs:     f.Slugs,
			Names:     f.Names,
		}
		for _, opt := range opts {
			opt(p)
		}
		resp, err := client.GcpMetricsIntegration.ListGcpMetricsIntegrations(p)
		if err != nil {
			return nil, err
		}

		// If payload or page token aren't set, no next page.
		nextToken = ""
		if resp.Payload != nil {
			for _, v := range resp.Payload.GcpMetricsIntegrations {
				result = append(result, v)
			}
			if resp.Payload.Page != nil {
				nextToken = resp.Payload.Page.NextToken
			}
		}
		if nextToken == "" {
			break
		}
	}
	return result, nil
}
