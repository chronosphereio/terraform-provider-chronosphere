// Copyright 2024 Chronosphere Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package chronosphere

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/intschema"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/apiclients"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/client/log_control_config"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/pkg/configv1/models"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/sliceutil"
	"github.com/chronosphereio/terraform-provider-chronosphere/chronosphere/tfschema"
)

// LogControlConfigConverter is a converter for LogControlConfig
func LogControlConfigFromModel(m *models.Configv1LogControlConfig) (*intschema.LogControlConfig, error) {
	return LogControlConfigConverter{}.fromModel(m)
}

func resourceLogControlConfig() *schema.Resource {
	r := newGenericResource[
		*models.Configv1LogControlConfig,
		intschema.LogControlConfig,
		*intschema.LogControlConfig,
	](
		"log_control_config",
		LogControlConfigConverter{},
		generatedLogControlConfig{},
	)

	return &schema.Resource{
		Schema:        tfschema.LogControlConfig,
		CreateContext: r.CreateContext,
		ReadContext:   r.ReadContext,
		UpdateContext: r.UpdateContext,
		DeleteContext: r.DeleteContext,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

type LogControlConfigConverter struct{}

func (LogControlConfigConverter) toModel(
	m *intschema.LogControlConfig,
) (*models.Configv1LogControlConfig, error) {
	return &models.Configv1LogControlConfig{
		Rules: sliceutil.Map(m.Rules, logControlRuleToModel),
	}, nil
}

func logControlRuleToModel(rule intschema.LogControlRule) *models.Configv1LogControlRule {
	return &models.Configv1LogControlRule{
		Name:      rule.Name,
		Mode:      models.LogControlRuleMode(rule.Mode),
		Filter:    rule.Filter,
		Type:      models.Configv1LogControlRuleType(rule.Type),
		Sample:    sampleToModel(rule.Sample),
		DropField: dropFieldToModel(rule.DropField),
	}
}

func sampleToModel(sample *intschema.LogControlRuleSample) *models.LogControlRuleSample {
	if sample == nil {
		return nil
	}
	return &models.LogControlRuleSample{
		Rate: sample.Rate,
	}
}

func dropFieldToModel(dropField *intschema.LogControlRuleDropField) *models.LogControlRuleDropField {
	if dropField == nil {
		return nil
	}
	return &models.LogControlRuleDropField{
		FieldRegex: dropField.FieldRegex,
		ParentPath: parentPathToModel(dropField.ParentPath),
	}
}

func parentPathToModel(parentPath *intschema.LogFieldPath) *models.Configv1LogFieldPath {
	if parentPath == nil {
		return nil
	}
	return &models.Configv1LogFieldPath{
		Selector: parentPath.Selector,
	}
}

func (LogControlConfigConverter) fromModel(
	m *models.Configv1LogControlConfig,
) (*intschema.LogControlConfig, error) {
	return &intschema.LogControlConfig{
		Rules: sliceutil.Map(m.Rules, logControlRuleFromModel),
	}, nil
}

func logControlRuleFromModel(rule *models.Configv1LogControlRule) intschema.LogControlRule {
	return intschema.LogControlRule{
		Name:      rule.Name,
		Mode:      string(rule.Mode),
		Filter:    rule.Filter,
		Type:      string(rule.Type),
		Sample:    sampleFromModel(rule.Sample),
		DropField: dropFieldFromModel(rule.DropField),
	}
}

func sampleFromModel(sample *models.LogControlRuleSample) *intschema.LogControlRuleSample {
	if sample == nil {
		return nil
	}
	return &intschema.LogControlRuleSample{
		Rate: sample.Rate,
	}
}

func dropFieldFromModel(dropField *models.LogControlRuleDropField) *intschema.LogControlRuleDropField {
	if dropField == nil {
		return nil
	}
	return &intschema.LogControlRuleDropField{
		FieldRegex: dropField.FieldRegex,
		ParentPath: parentPathFromModel(dropField.ParentPath),
	}
}

func parentPathFromModel(parentPath *models.Configv1LogFieldPath) *intschema.LogFieldPath {
	if parentPath == nil {
		return nil
	}
	return &intschema.LogFieldPath{
		Selector: parentPath.Selector,
	}
}

// TODO: This should be generated by generateresources
type generatedLogControlConfig struct{}

func (generatedLogControlConfig) slugOf(e *models.Configv1LogControlConfig) string {
	return "log_control_config_singleton"
}

func (generatedLogControlConfig) create(
	ctx context.Context,
	clients apiclients.Clients,
	m *models.Configv1LogControlConfig,
	dryRun bool,
) (string, error) {
	req := &log_control_config.CreateLogControlConfigParams{
		Context: ctx,
		Body: &models.Configv1CreateLogControlConfigRequest{
			LogControlConfig: m,
			DryRun:           dryRun,
		},
	}
	_, err := clients.ConfigV1.LogControlConfig.CreateLogControlConfig(req)
	if err != nil {
		return "", err
	}
	return "log_control_config_singleton", nil
}

func (generatedLogControlConfig) read(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) (*models.Configv1LogControlConfig, error) {
	req := &log_control_config.ReadLogControlConfigParams{
		Context: ctx,
	}
	resp, err := clients.ConfigV1.LogControlConfig.ReadLogControlConfig(req)
	if err != nil {
		return nil, err
	}
	return resp.Payload.LogControlConfig, nil
}

func (generatedLogControlConfig) update(
	ctx context.Context,
	clients apiclients.Clients,
	m *models.Configv1LogControlConfig,
	params updateParams,
) error {
	req := &log_control_config.UpdateLogControlConfigParams{
		Context: ctx,
		Body: &models.Configv1UpdateLogControlConfigRequest{
			LogControlConfig: m,
			CreateIfMissing:  params.createIfMissing,
			DryRun:           params.dryRun,
		},
	}
	_, err := clients.ConfigV1.LogControlConfig.UpdateLogControlConfig(req)
	return err
}

func (generatedLogControlConfig) delete(
	ctx context.Context,
	clients apiclients.Clients,
	slug string,
) error {
	req := &log_control_config.DeleteLogControlConfigParams{
		Context: ctx,
	}
	_, err := clients.ConfigV1.LogControlConfig.DeleteLogControlConfig(req)
	return err
}
